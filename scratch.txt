================================================================================
CODE REVIEW & EXECUTION SIMULATION
================================================================================
Date: 2025-01-07
Test Case: Text-based PDF extraction with full pipeline
Command: python main.py --file ./contracts/example.pdf --out ./results/example.json

================================================================================
INITIAL STATE
================================================================================
ENVIRONMENT:
- Python version: 3.10
- Working directory: D:\dev\projects\msa_extractor
- Config values:
  - GEMINI_API_KEY: Set (assumed)
  - EXTRACTION_STRATEGY: "auto"
  - OCR_ENGINE: "tesseract"
  - MAX_TEXT_LENGTH: 50000
  - LOG_LEVEL: "INFO"
  - LOG_FILE_ENABLED: true
  - LOG_CONSOLE_ENABLED: true

FILE SYSTEM:
- Input file: ./contracts/example.pdf (text-based PDF, 5 pages)
- Output file: ./results/example.json (to be created)
- Log file: ./logs/msa_extractor_2025-01-07.log (to be created)

================================================================================
EXECUTION FLOW - STEP BY STEP
================================================================================

STEP 1: main.py - main() (entry point)
--------------------------------------------------------------------------------
Line 151-245: Main CLI entry point

OBJECT STATE:
- args: Namespace object from argparse
  - file: "./contracts/example.pdf"
  - out: "./results/example.json"
  - dir: None
  - out_dir: None
  - strategy: None
  - parallel: 1
  - validate_only: False

EXECUTION:
- Line 204: validate_config() called
  - Checks GEMINI_API_KEY exists → True
  - No exception raised
- Line 205: Check if args.validate_only → False
- Line 207: Check if args.file → True
- Line 208: extract_single_file() called with:
  - file_path: "./contracts/example.pdf"
  - output_path: "./results/example.json"
  - strategy: None

MEMORY:
- args: Namespace object
- Logger initialized via utils.logger

NEXT: Call extract_single_file()

================================================================================

STEP 2: main.py - extract_single_file()
--------------------------------------------------------------------------------
Line 23-73: Single file extraction function

OBJECT STATE:
- file_path: "./contracts/example.pdf"
- output_path: "./results/example.json"
- strategy: None
- logger: Logger instance (from utils.logger)

EXECUTION:
- Line 38: validate_config() called
  - Checks GEMINI_API_KEY → True
  - No exception raised
- Line 41: ExtractionCoordinator() created
  - Calls __init__()
- Line 44: logger.info("Extracting metadata from: ./contracts/example.pdf")
- Line 45: coordinator.extract_metadata() called with:
  - file_path: "./contracts/example.pdf"
  - strategy: None

MEMORY:
- coordinator: ExtractionCoordinator instance
- Logger initialized

NEXT: Call coordinator.extract_metadata()

================================================================================

STEP 3: extractors/extraction_coordinator.py - ExtractionCoordinator.__init__()
--------------------------------------------------------------------------------
Line 25-39: Coordinator initialization

OBJECT STATE:
- gemini_client: None (passed as None)
- self.gemini_client: Will be created
- self.strategy_factory: Will be created
- self.logger: Logger instance

EXECUTION:
- Line 33: Check if gemini_client is None → True
- Line 34: Check if GeminiClient → True (class exists)
- Line 35: self.gemini_client = GeminiClient() created
  - Calls GeminiClient.__init__()
- Line 38: self.strategy_factory = StrategyFactory(gemini_client=self.gemini_client)
  - Calls StrategyFactory.__init__()
- Line 39: self.logger = get_logger(self.__class__.__module__)

MEMORY:
- self.gemini_client: GeminiClient instance
- self.strategy_factory: StrategyFactory instance
- self.logger: Logger instance

NEXT: GeminiClient.__init__() → StrategyFactory.__init__() → extract_metadata()

================================================================================

STEP 4: ai/gemini_client.py - GeminiClient.__init__()
--------------------------------------------------------------------------------
Line 29-45: Gemini client initialization

OBJECT STATE:
- api_key: None (default)
- GEMINI_API_KEY: Set in config
- self.api_key: Will be set
- self.text_model: Will be created
- self.vision_model: Will be created
- self.schema_validator: Will be created
- self.logger: Will be created

EXECUTION:
- Line 37: self.api_key = api_key or GEMINI_API_KEY
  - api_key is None → uses GEMINI_API_KEY
  - self.api_key = "..." (assumed set)
- Line 38: Check if not self.api_key → False
- Line 41: genai.configure(api_key=self.api_key)
  - Configures Gemini API
- Line 42: self.text_model = genai.GenerativeModel(GEMINI_TEXT_MODEL)
  - Creates text model instance
- Line 43: self.vision_model = genai.GenerativeModel(GEMINI_VISION_MODEL)
  - Creates vision model instance
- Line 44: self.schema_validator = SchemaValidator()
  - Calls SchemaValidator.__init__()
- Line 45: self.logger = get_logger(self.__class__.__module__)

MEMORY:
- self.api_key: String (API key)
- self.text_model: GenerativeModel instance
- self.vision_model: GenerativeModel instance
- self.schema_validator: SchemaValidator instance
- self.logger: Logger instance

NEXT: SchemaValidator.__init__() → StrategyFactory.__init__() → extract_metadata()

================================================================================

STEP 5: ai/schema.py - SchemaValidator.__init__()
--------------------------------------------------------------------------------
Line 20-24: Schema validator initialization

OBJECT STATE:
- self.schema: Will be built
- self.logger: Will be created

EXECUTION:
- Line 23: self.schema = self._build_json_schema()
  - Calls _build_json_schema()
- Line 24: self.logger = get_logger(self.__class__.__module__)

MEMORY:
- self.schema: Dict with JSON schema structure
- self.logger: Logger instance

NEXT: _build_json_schema() → StrategyFactory.__init__() → extract_metadata()

================================================================================

STEP 6: ai/schema.py - SchemaValidator._build_json_schema()
--------------------------------------------------------------------------------
Line 26-52: Build JSON schema from METADATA_SCHEMA

OBJECT STATE:
- METADATA_SCHEMA: Dict from config.py
  - Contract Lifecycle: 4 fields
  - Commercial Operations: 3 fields
  - Risk & Compliance: 4 fields
- schema: Will be built

EXECUTION:
- Line 27: schema = {"type": "object", "properties": {}, "required": []}
- Line 29: Loop through METADATA_SCHEMA.items()
  - category: "Contract Lifecycle"
  - fields: Dict with 4 field names
- Line 30: schema["properties"][category] = {"type": "object", "properties": {}}
- Line 32: Loop through fields.items()
  - field_name: "Execution Date"
  - field_info: Dict with definition
- Line 33: schema["properties"][category]["properties"][field_name] = {"type": "string"}
- Line 34: schema["required"].append(f"{category}.{field_name}")
- Repeat for all 11 fields
- Line 51: return schema

MEMORY:
- schema: Dict with complete JSON schema
  - properties: 3 categories, 11 fields total
  - required: 11 field paths

NEXT: Return to __init__() → StrategyFactory.__init__() → extract_metadata()

================================================================================

STEP 7: extractors/strategy_factory.py - StrategyFactory.__init__()
--------------------------------------------------------------------------------
Line 27-36: Strategy factory initialization

OBJECT STATE:
- gemini_client: GeminiClient instance (passed)
- self.gemini_client: Will be set
- self.logger: Will be created

EXECUTION:
- Line 35: self.gemini_client = gemini_client
  - Sets reference to GeminiClient instance
- Line 36: self.logger = get_logger(self.__class__.__module__)

MEMORY:
- self.gemini_client: Reference to GeminiClient instance
- self.logger: Logger instance

NEXT: Return to ExtractionCoordinator.__init__() → extract_metadata()

================================================================================

STEP 8: extractors/extraction_coordinator.py - extract_metadata()
--------------------------------------------------------------------------------
Line 41-73: Main extraction method

OBJECT STATE:
- file_path: "./contracts/example.pdf"
- strategy: None
- self.gemini_client: GeminiClient instance
- self.strategy_factory: StrategyFactory instance
- self.logger: Logger instance

EXECUTION:
- Line 50: self._extract_text() called with:
  - file_path: "./contracts/example.pdf"
  - strategy: None
- Returns ExtractedTextResult

MEMORY:
- extraction_result: ExtractedTextResult (to be returned from _extract_text)

NEXT: Call _extract_text()

================================================================================

STEP 9: extractors/extraction_coordinator.py - _extract_text()
--------------------------------------------------------------------------------
Line 76-99: Text extraction coordination

OBJECT STATE:
- file_path: "./contracts/example.pdf"
- strategy: None
- file_ext: Will be determined

EXECUTION:
- Line 88: file_ext = Path(file_path).suffix.lower()
  - file_ext = ".pdf"
- Line 90: Check if file_ext == ".pdf" → True
- Line 91: self._extract_from_pdf() called with:
  - file_path: "./contracts/example.pdf"
  - strategy: None

MEMORY:
- file_ext: ".pdf"
- result: ExtractedTextResult (to be returned from _extract_from_pdf)

NEXT: Call _extract_from_pdf()

================================================================================

STEP 10: extractors/extraction_coordinator.py - _extract_from_pdf()
--------------------------------------------------------------------------------
Line 100-139: PDF extraction coordination

OBJECT STATE:
- file_path: "./contracts/example.pdf"
- strategy: None
- extractor: Will be created
- result: Will be returned

EXECUTION:
- Line 112: extractor = self.strategy_factory.get_extractor(file_path, strategy)
  - Calls StrategyFactory.get_extractor()
- Line 113: result = extractor.extract(file_path)
  - Calls extractor.extract()
- Line 117: Check if result.metadata.get("is_scanned") → False (text-based PDF)
- Line 139: return result

MEMORY:
- extractor: BaseExtractor instance (PDFExtractor)
- result: ExtractedTextResult

NEXT: StrategyFactory.get_extractor() → extractor.extract()

================================================================================

STEP 11: extractors/strategy_factory.py - get_extractor()
--------------------------------------------------------------------------------
Line 38-77: Get appropriate extractor

OBJECT STATE:
- file_path: "./contracts/example.pdf"
- strategy: None
- EXTRACTION_STRATEGY: "auto" (from config)

EXECUTION:
- Line 48: strategy = strategy or EXTRACTION_STRATEGY
  - strategy is None → uses "auto"
- Line 49: file_ext = Path(file_path).suffix.lower()
  - file_ext = ".pdf"
- Line 56: Check if file_ext == ".pdf" → True
- Line 57: Check if strategy == "auto" → True
- Line 58: self._get_auto_strategy_extractor() called with file_path

MEMORY:
- strategy: "auto"
- file_ext: ".pdf"
- extractor: BaseExtractor (to be returned)

NEXT: Call _get_auto_strategy_extractor()

================================================================================

STEP 12: extractors/strategy_factory.py - _get_auto_strategy_extractor()
--------------------------------------------------------------------------------
Line 79-103: Auto strategy extractor selection

OBJECT STATE:
- file_path: "./contracts/example.pdf"
- pdf_extractor: Will be created
- pdf_type: Will be detected

EXECUTION:
- Line 83: pdf_extractor = PDFExtractor(gemini_client=self.gemini_client)
  - Creates PDFExtractor instance
- Line 84: pdf_type = pdf_extractor._detect_pdf_type(file_path)
  - Calls _detect_pdf_type()
- Line 85: pdf_extractor._cached_pdf_type = pdf_type
  - Caches PDF type to avoid re-detection
- Line 87: self.logger.info(f"Auto strategy: Detected PDF type: {pdf_type}")
- Line 89: Check if pdf_type == "text" → True
- Line 91: return pdf_extractor

MEMORY:
- pdf_extractor: PDFExtractor instance
- pdf_type: "text" (detected)
- pdf_extractor._cached_pdf_type: "text"

NEXT: _detect_pdf_type() → return pdf_extractor → extractor.extract()

================================================================================

STEP 13: extractors/pdf_extractor.py - _detect_pdf_type()
--------------------------------------------------------------------------------
Line 104-160: PDF type detection

OBJECT STATE:
- file_path: "./contracts/example.pdf"
- doc: Will be opened
- total_pages: Will be determined
- text_pages: Will be counted

EXECUTION:
- Line 114: doc = None (initialized)
- Line 116: doc = fitz.open(file_path)
  - Opens PDF document
- Line 117: total_pages = len(doc)
  - total_pages = 5
- Line 119: Check if total_pages == 0 → False
- Line 122: text_pages = 0
- Line 123: min_text_length = 50
- Line 126: sample_pages = min(5, total_pages)
  - sample_pages = 5
- Line 127: pages_to_check = [0, 1, 2, 3, 4]
- Line 128: Check if total_pages > sample_pages → False
- Line 131: Loop through pages_to_check:
  - page_num = 0: page = doc.load_page(0), text = "...", len(text) = 500 > 50 → text_pages = 1
  - page_num = 1: page = doc.load_page(1), text = "...", len(text) = 600 > 50 → text_pages = 2
  - page_num = 2: page = doc.load_page(2), text = "...", len(text) = 550 > 50 → text_pages = 3
  - page_num = 3: page = doc.load_page(3), text = "...", len(text) = 580 > 50 → text_pages = 4
  - page_num = 4: page = doc.load_page(4), text = "...", len(text) = 200 > 50 → text_pages = 5
- Line 141: checked_pages = 5
- Line 142: text_ratio = text_pages / checked_pages
  - text_ratio = 5 / 5 = 1.0
- Line 145: Check if text_ratio > 0.8 → True
- Line 146: return "text"
- Line 157: finally block:
  - Check if doc is not None → True
  - doc.close() called

MEMORY:
- doc: fitz.Document (closed after detection)
- pdf_type: "text"
- text_pages: 5
- text_ratio: 1.0

NEXT: Return "text" → return pdf_extractor → extractor.extract()

================================================================================

STEP 14: extractors/pdf_extractor.py - PDFExtractor.extract()
--------------------------------------------------------------------------------
Line 57-102: Main extraction method

OBJECT STATE:
- file_path: "./contracts/example.pdf"
- self._cached_pdf_type: "text" (set by StrategyFactory)
- self.logger: Logger instance
- self.preprocessor: ImagePreprocessor instance (from __init__)

EXECUTION:
- Line 68: self._log_extraction_start(file_path)
  - Logs: "Starting extraction for: ./contracts/example.pdf"
- Line 70: self.validate_file(file_path)
  - Calls BaseExtractor.validate_file()
- Line 72: Check if self._cached_pdf_type is not None → True
- Line 75: pdf_type = self._cached_pdf_type
  - pdf_type = "text"
- Line 76: self.logger.debug("Using cached PDF type: text")
- Line 78: Check if pdf_type == "text" → True
- Line 80: result = self._extract_text_based(file_path)
  - Calls _extract_text_based()
- Line 91: self._log_extraction_complete(file_path, result)
  - Logs completion
- Line 92: return result

MEMORY:
- pdf_type: "text" (from cache)
- result: ExtractedTextResult (from _extract_text_based)

NEXT: BaseExtractor.validate_file() → _extract_text_based()

================================================================================

STEP 15: extractors/base_extractor.py - validate_file()
--------------------------------------------------------------------------------
Line 59-84: File validation

OBJECT STATE:
- file_path: "./contracts/example.pdf"
- path: Path object

EXECUTION:
- Line 73: path = Path(file_path)
- Line 75: Check if not path.exists() → False
- Line 78: Check if not path.is_file() → False
- Line 81: Check if path.stat().st_size == 0 → False
- Line 84: return True

MEMORY:
- path: Path object
- File is valid

NEXT: Return True → _extract_text_based()

================================================================================

STEP 16: extractors/pdf_extractor.py - _extract_text_based()
--------------------------------------------------------------------------------
Line 162-241: Text-based PDF extraction

OBJECT STATE:
- file_path: "./contracts/example.pdf"
- doc: Will be opened
- text_blocks: Will be collected
- full_text: Will be collected
- page_count: Will be determined

EXECUTION:
- Line 172: doc = fitz.open(file_path)
  - Opens PDF document
- Line 174: Check if doc.is_encrypted → False
- Line 181: text_blocks = []
- Line 182: full_text = []
- Line 183: page_count = len(doc)
  - page_count = 5
- Line 185: Loop through range(page_count):
  - page_num = 0: page = doc.load_page(0)
    - text_dict = page.get_text("dict")
    - Loop through blocks, lines, spans
    - Extract text and metadata
    - text_blocks.append({...})
    - full_text.append(text)
  - Repeat for pages 1-4
- Line 217: raw_text = " ".join(full_text)
  - Combines all text
- Line 221: metadata = doc.metadata
  - Gets PDF metadata
- Line 223: result = ExtractedTextResult(...)
  - Creates result object
- Line 236: return result
- Line 238: finally block:
  - doc.close() called

MEMORY:
- doc: fitz.Document (closed in finally)
- result: ExtractedTextResult
  - raw_text: Full document text
  - structured_text: List of text blocks
  - headers: [] (empty, not extracted here)
  - metadata: Dict with file info

NEXT: Return result → _extract_from_pdf() → _process_with_llm()

================================================================================

STEP 17: extractors/extraction_coordinator.py - _extract_from_pdf() (continued)
--------------------------------------------------------------------------------
Line 115-139: OCR handling and return

OBJECT STATE:
- result: ExtractedTextResult (from extractor.extract())
- is_scanned: False (from result.metadata)
- extraction_method: "text" (from result.metadata)

EXECUTION:
- Line 117: Check if result.metadata.get("is_scanned") → False
  - Text-based PDF, skip OCR
- Line 139: return result

MEMORY:
- result: ExtractedTextResult (unchanged)

NEXT: Return result → extract_metadata() → _process_with_llm()

================================================================================

STEP 18: extractors/extraction_coordinator.py - extract_metadata() (continued)
--------------------------------------------------------------------------------
Line 64-73: LLM processing

OBJECT STATE:
- extraction_result: ExtractedTextResult (from _extract_text())
- is_scanned: False
- extraction_strategy: "pymupdf" (from result.metadata)

EXECUTION:
- Line 66: Check if extraction_result.metadata.get("is_scanned") → False
- Line 67: Check if extraction_result.metadata.get("extraction_strategy") == "gemini_vision" → False
- Line 70: metadata = self._process_with_llm(extraction_result)
  - Calls _process_with_llm()

MEMORY:
- extraction_result: ExtractedTextResult
- metadata: Dict (to be returned from _process_with_llm)

NEXT: Call _process_with_llm()

================================================================================

STEP 19: extractors/extraction_coordinator.py - _process_with_llm()
--------------------------------------------------------------------------------
Line 155-182: LLM processing for metadata extraction

OBJECT STATE:
- extraction_result: ExtractedTextResult
  - raw_text: Full document text
  - metadata: Dict with file info
- self.gemini_client: GeminiClient instance

EXECUTION:
- Line 165: Check if not extraction_result.raw_text → False
  - Text exists, continue
- Line 171: try block:
  - Line 173: metadata = self.gemini_client.extract_metadata_from_text(extraction_result.raw_text)
    - Calls GeminiClient.extract_metadata_from_text()
- Line 176: return metadata
- Line 177: except LLMError as e:
  - Not triggered (assume success)

MEMORY:
- metadata: Dict (to be returned from extract_metadata_from_text)

NEXT: Call extract_metadata_from_text()

================================================================================

STEP 20: ai/gemini_client.py - extract_metadata_from_text()
--------------------------------------------------------------------------------
Line 47-97: Text-based metadata extraction

OBJECT STATE:
- text: Full document text (from extraction_result.raw_text)
- original_length: Will be determined
- MAX_TEXT_LENGTH: 50000 (from config)
- prompt: Will be built
- response: Will be received
- metadata: Will be parsed

EXECUTION:
- Line 58: original_length = len(text)
  - original_length = 2500 (example)
- Line 59: Check if original_length > MAX_TEXT_LENGTH → False
  - No truncation needed
- Line 69: prompt = self._build_extraction_prompt(text)
  - Calls _build_extraction_prompt()
- Line 72: response = self.text_model.generate_content(prompt)
  - Calls Gemini API
  - response.text contains JSON string
- Line 76: metadata = self._parse_json_response(response.text)
  - Calls _parse_json_response()
- Line 78: is_valid, error = self.schema_validator.validate(metadata)
  - VALIDATES BEFORE NORMALIZATION (FIXED!)
  - Checks raw LLM response
  - If incomplete, is_valid = False
- Line 79: Check if not is_valid → False (assume complete response)
- Line 87: metadata = self.schema_validator.normalize(metadata)
  - Fills missing fields with "Not Found"
- Line 90: return metadata

MEMORY:
- text: String (2500 chars)
- prompt: String (with field definitions)
- response: GenerateContentResponse
- metadata: Dict (normalized, all fields present)

NEXT: _build_extraction_prompt() → _parse_json_response() → return metadata

================================================================================

STEP 21: ai/gemini_client.py - _build_extraction_prompt()
--------------------------------------------------------------------------------
Line 142-240: Build extraction prompt

OBJECT STATE:
- text: Full document text
- FIELD_DEFINITIONS: Dict from config.py
- METADATA_SCHEMA: Dict from config.py
- prompt: Will be built

EXECUTION:
- Line 144: prompt = "..." (template start)
- Line 147: Loop through FIELD_DEFINITIONS.items()
  - Adds field definitions to prompt
- Line 160: prompt += "\n\nEXTRACTION RULES:\n"
  - Adds extraction rules
- Line 180: prompt += "\n\nSEARCH GUIDANCE:\n"
  - Adds search guidance (for varied document structures)
- Line 200: prompt += "\n\nSCHEMA STRUCTURE:\n"
  - Adds schema structure
- Line 220: prompt += "\n\nCONTRACT TEXT:\n"
- Line 221: prompt += text
  - Adds contract text
- Line 223: prompt += "\n\nPlease extract the metadata..."
  - Adds final instructions
- Line 224: return prompt

MEMORY:
- prompt: String (comprehensive prompt with field definitions, rules, and text)

NEXT: Return prompt → generate_content() → _parse_json_response()

================================================================================

STEP 22: ai/gemini_client.py - _parse_json_response()
--------------------------------------------------------------------------------
Line 250-292: Parse JSON from LLM response

OBJECT STATE:
- response_text: JSON string from LLM
- text: Will be extracted
- metadata: Will be parsed

EXECUTION:
- Line 252: response_text = response.text
  - Contains JSON string (possibly with markdown)
- Line 254: Check if "```json" in response_text → False (assume clean JSON)
- Line 256: Check if "```" in response_text → False
- Line 258: text = response_text.strip()
- Line 282: try block:
  - Line 283: return json.loads(text)
    - Parses JSON
    - Returns Dict

MEMORY:
- response_text: String (JSON)
- metadata: Dict (parsed JSON)

NEXT: Return metadata → validate() → normalize() → return metadata

================================================================================

STEP 23: ai/gemini_client.py - extract_metadata_from_text() (continued)
--------------------------------------------------------------------------------
Line 78-90: Validation and normalization

OBJECT STATE:
- metadata: Dict (raw from LLM)
- is_valid: Will be determined
- error: Will be set if invalid

EXECUTION:
- Line 78: is_valid, error = self.schema_validator.validate(metadata)
  - VALIDATES RAW LLM RESPONSE (FIXED!)
  - Checks if all required fields present
  - Checks if types are correct
  - Example: metadata has 10 fields, missing 1 → is_valid = False
- Line 79: Check if not is_valid → False (assume complete)
  - If True, logs warning about incomplete response
- Line 87: metadata = self.schema_validator.normalize(metadata)
  - Fills missing fields with "Not Found"
  - Ensures all 11 fields present
- Line 90: return metadata

MEMORY:
- metadata: Dict (normalized, all 11 fields present)

NEXT: Return metadata → _process_with_llm() → extract_metadata() → main.py

================================================================================

STEP 24: extractors/extraction_coordinator.py - _process_with_llm() (continued)
--------------------------------------------------------------------------------
Line 176-182: Return metadata

OBJECT STATE:
- metadata: Dict (from GeminiClient)

EXECUTION:
- Line 176: return metadata

MEMORY:
- metadata: Dict (complete metadata)

NEXT: Return metadata → extract_metadata() → main.py

================================================================================

STEP 25: extractors/extraction_coordinator.py - extract_metadata() (final)
--------------------------------------------------------------------------------
Line 71-73: Return final metadata

OBJECT STATE:
- metadata: Dict (from _process_with_llm())

EXECUTION:
- Line 71: return metadata

MEMORY:
- metadata: Dict (complete metadata)

NEXT: Return metadata → main.py extract_single_file()

================================================================================

STEP 26: main.py - extract_single_file() (continued)
--------------------------------------------------------------------------------
Line 45-66: Validation and saving

OBJECT STATE:
- metadata: Dict (from coordinator)
- validator: Will be created
- is_valid: Will be determined

EXECUTION:
- Line 48: validator = SchemaValidator()
  - Creates new validator instance
- Line 49: is_valid, error = validator.validate(metadata)
  - Validates already-normalized data
  - Should always pass (all fields present)
- Line 51: Check if not is_valid → False
  - If True, normalizes again (redundant)
- Line 56: Check if output_path → True
- Line 58: output_path = Path("./results/example.json")
- Line 59: output_path.parent.mkdir(parents=True, exist_ok=True)
  - Creates ./results/ directory
- Line 61: with open(output_path, 'w', encoding='utf-8') as f:
  - Opens file for writing
- Line 62: json.dump(metadata, f, indent=2, ensure_ascii=False)
  - Writes JSON to file
- Line 64: logger.info(f"Metadata saved to: ./results/example.json")
- Line 66: return metadata

MEMORY:
- metadata: Dict (saved to file)
- File written: ./results/example.json

NEXT: Return metadata → main() → exit

================================================================================

STEP 27: main.py - main() (final)
--------------------------------------------------------------------------------
Line 217-223: Final steps

OBJECT STATE:
- metadata: Dict (from extract_single_file)

EXECUTION:
- Line 217: metadata = {...} (from extract_single_file)
- Line 220: Check if not args.out → False (output file specified)
- Line 223: return 0

EXIT CODE: 0 (success)

MEMORY:
- All objects cleaned up
- File saved successfully

================================================================================
FINAL STATE
================================================================================

FILES CREATED:
- ./results/example.json (contains extracted metadata)
- ./logs/msa_extractor_2025-01-07.log (contains logs)

OBJECTS DESTROYED:
- All local objects cleaned up by Python GC
- File handles closed
- PDF documents closed (in finally blocks)
- API connections closed

OUTPUT FILE CONTENT:
{
  "Contract Lifecycle": {
    "Execution Date": "2025-03-14",
    "Effective Date": "2025-04-01",
    "Expiration / Termination Date": "2028-03-31",
    "Authorized Signatory": "John Doe, VP of Operations"
  },
  "Commercial Operations": {
    "Billing Frequency": "Monthly",
    "Payment Terms": "Net 30 days from invoice date",
    "Expense Reimbursement Rules": "Reimbursed as per client travel policy"
  },
  "Risk & Compliance": {
    "Indemnification Clause Reference": "Section 12 – Indemnification",
    "Limitation of Liability Cap": "Aggregate liability not to exceed fees paid in previous 12 months",
    "Insurance Requirements": "CGL $2M per occurrence; Workers Comp as per law",
    "Warranties / Disclaimers": "Services to be performed in a professional manner"
  }
}

================================================================================
ISSUES IDENTIFIED
================================================================================

1. VALIDATION ORDER FIXED ✅
   - Location: ai/gemini_client.py:78-87
   - Issue: Previously validated after normalization (always passed)
   - Fix: Now validates BEFORE normalization
   - Status: ✅ Fixed - Can now detect incomplete LLM responses

2. REDUNDANT VALIDATION IN main.py
   - Location: main.py:48-54
   - Issue: Validates already-normalized data (always passes)
   - Impact: Low - Redundant but harmless
   - Recommendation: Could remove or keep as safety check

3. RESOURCE MANAGEMENT ✅
   - Location: extractors/pdf_extractor.py
   - Issue: Document closing in finally blocks
   - Status: ✅ Fixed - All documents properly closed

4. PDF TYPE DETECTION CACHING ✅
   - Location: extractors/strategy_factory.py:84-85
   - Issue: PDF type detected twice (once in factory, once in extractor)
   - Fix: Caching implemented
   - Status: ✅ Fixed - Uses cached value

5. LOGGING AND ERROR HANDLING ✅
   - Location: All modules
   - Issue: Inconsistent logging and error handling
   - Status: ✅ Fixed - Centralized logging and custom exceptions

================================================================================
END OF SIMULATION
================================================================================
